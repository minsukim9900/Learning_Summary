# SW문제해결응용 - 동적계획법

## 피보나치 수열

- 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치 수열
- 피보나치 수열의 i 번째 값을 계산하는 함수 F를 정의하면 다음과 같다.
    - F(0) = 0, F(1) = 1
    - F(i) = F(i-1) + F(i-2) for i≥ 2
- 피보나치 수를 구하는 재귀함수
    - 연산 횟수가 너무 많아진다.

## Memoization

- 메모이제이션은 컴퓨터 프로그램을 실행할 때, 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
- 동적 계획법의 핵심이 되는 기술
- “memoization”은 글자 그대로 해석하면 “메모리에 넣기(to put in memory)” 라는 의미이며 “기억되어야 할 것”이라는 뜻의 라틴어 memorandum에서 파생
- 흔히 “기억하기”, “암기하기”라는 뜻의 memorization과 혼동하지만, 정확한 단어는 memoization이다.
- 동사형은 memoize이다.

### 메모이제이션

- 추가적인 메모리 공간 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용 → 실행 속도 저하 또는 오버플로어가 발생할 수 있음.

## 동적 계획 알고리즘

- 동적 계획 (Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 최적화 문제 : 최적(최대값이나 최소값 같은) 값을 구하는 문제
    - 해당 문제에 여러 해가 있을 수 있다.
    - 특정한 최적 해를 구하는 것이 아니라 어떤 최적 해를 구하는 것이다.
- 동적 계획 알고리즘은 먼저 작은 부분 문제들을 해들을 구하고,
이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법이다.
- 동적 계획법을 적용하려는 문제는 필히 다음과 같은 요건을 가지고 있어야 한다.
    - 중복 부분 문제 구조 (Overlapping subproblems)
    - 최적 부분 문제 구조 (Optimal substructure)

### 중복 부분 문제 구조

- DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고, 작은 문제들의 최적 해(Optimal Solution)을 이용하여 순환적으로 큰 문제를 해결한다.
    - 순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 수학적 도구인 점화식을 사용한다.
- DP는 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(Table)에 저장하게 된다.
- 그리고 이렇게 저장된 해들이 다시 필요할 때 마다 해를 얻기 위해 다시 문제를 재계산하지 않고, table의 참조를 통해서 중복된 계산을 피하기 된다.

### 최적 부분 문제 구조

- 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아니다.
- 주어진 문제가 최적화의 원칙(Princlple of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용
- 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다.
- 동적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하기 때문에 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다.

### 분할 정복과 동적 계획법의 비교

- 분할 정복
    - 연관 없는 부분 문제로 분할한다.
    - 부분 문제를 재귀적으로 해결한다.
    - 부분 문제를 해를 결합(Combine) 한다.
    - 병합 정렬 / 퀵 정렬
- DP
    - 부분 문제들이 연관이 없으면 적용할 수 없다. (즉, 부분 문제들은 더 작은 부분 문제들을 공유한다.)
    - 모든 부분 문제를 한 번만 계산하고, 결과를 저장하고 재 사용한다.
    - (분할 정복은 같은 부분 문제가 나타날 경우 다시 계산한다.)
    - DP에는 부분 문제들 사이에 의존적 관계가 존재
    - 이러한 관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 함축적인 순서(Implicit order)라고 한다.
    - 분할 정복은 하향식 방법으로, DP는 상향식 방법으로 접근한다.

### 3단계 DP 적용 접근 방법

- 최적해 구조의 특성을 파악하라.
    - 문제를 부분 문제로 나눈다.
- 최적해의 값을 재귀적으로 정의하라.
    - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다.
- 상향식 방법으로 최적해의 값을 계산하라.
    - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다.
    - 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다.

## 0-1 Knapsack

- 배낭(Knapsack) 문제는 n개의 물건과 각 물건 i의 무게 w와 가치 v가 주어지고, 배낭의 용량은 W일 때, 배낭에 담을 수 있는 물건의 최대 가치를 찾는 문제이다.
- 단, 배낭에 담은 무게의 합이 W를 초과하지 말아야 하고, 각 물건은 1개씩만 있다.
- 먼저 배낭 문제의 부분 문제를 찾아내기 위해 문제의 주어진 조건 살펴보기
    - 물건, 물건의 무게, 물건의 가치, 배낭의 용량, 모두 4가지의 요소가 있다.
- 이 중에서 물건과 물건의 무게는 부분 문제를 정의하는 것이 반드시 필요하다.
- 왜냐하면 배낭이 비어 있는 상태에서 시작하여 물건을 하나씩 배낭에 담는 것과 안 담는 것을 현재 배낭에 들어있는 물건의 가치의 합에 근거하여 결정해야 하기 때문
- 또한 물건을 배낭에 담으려고 할 경우 배낭 용랴으이 초과 여부를 검사해야 한다.
- 따라서 배낭 문제의 부분 문제를 아래와 같이 정의할 수 있다.
    - W = 배낭의 용량(kg)
    - (v(i) w((i)) = 가치(만원), 무게(kg) 물건
    - K[i, w] =물건 1 ~ i 까지만 고려하고, (임시) 배낭의 용량이 w일 때의 최대 가치
    (단, i = 1, 2, … , n 이고 / w =  1, 2, 3, …, W이다.)